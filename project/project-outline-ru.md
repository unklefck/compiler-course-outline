### **Общие допущения по стеку проекта**
*   **Исходный язык:** Упрощённый язык, похожий на C или Pascal (например, "MiniJava", "TinyC").
*   **Язык реализации:** C++, Rust или Python (для быстрого прототипирования).
*   **Целевая платформа:** Ассемблер x86-64 (синтаксис NASM/GAS).
*   **ОС:** Linux (для использования чистой SysV ABI).

---

### **План этапов (Milestone Plan)**

#### **Этап 1 (Спринт 1): Основа проекта и лексический анализ**
*   **Цель:** Создать проект и преобразовать исходный код в токены.
*   **Ключевые результаты:**
    1.  Репозиторий проекта (Git) с понятной системой сборки (Make/CMake/Cargo).
    2.  Формальная спецификация *исходного языка* (лексические элементы).
    3.  Рабочий **лексер (scanner)**, который читает исходный файл и выводит список токенов (например, `INT_LITERAL: 42`, `IDENTIFIER: "foo"`, `KEYWORD: "if"`).
    4.  Набор тестов с корректными и некорректными потоками токенов.
*   **Дополнительная задача:** Реализовать препроцессор для комментариев и простых макросов `#define`.

#### **Этап 2 (Спринт 2): Синтаксический анализ и Абстрактное синтаксическое дерево**
*   **Цель:** Определить грамматику и построить парсер для создания Абстрактного синтаксического дерева (АСД).
*   **Ключевые результаты:**
    1.  Формальная **Контекстно-свободная грамматика (КСГ)** для языка.
    2.  Рабочий **парсер** (скорее всего, рекурсивного спуска), который потребляет токены от лексера.
    3.  Парсер строит и выводит в память чётко определённую структуру данных **АСД**.
    4.  Визуализатор или "красивая" печать АСД (в .dot или текстовом виде).
    5.  Набор тестов с синтаксически корректными и некорректными программами.
*   **Дополнительная задача:** Реализовать надёжное восстановление после ошибок в парсере.

#### **Этап 3 (Спринт 3): Семантический анализ и таблица символов**
*   **Цель:** Перейти от синтаксиса к смыслу. Проверить объявления, типы и области видимости.
*   **Ключевые результаты:**
    1.  Структура данных **таблицы символов**, поддерживающая вложенные области видимости (например, для блоков, функций).
    2.  **Семантический анализатор**, который обходит АСД, чтобы:
        *   Заполнить таблицу символов объявлениями переменных/функций.
        *   Выполнить проверку типов для выражений и присваиваний.
        *   Проверить соответствие аргументов вызовов функций их сигнатурам.
    3.  Понятные сообщения об ошибках для семантических нарушений (например, "Необъявленная переменная `x`", "Несовпадение типов при присваивании").
    4.  Проверенное, "декорированное" АСД, готовое для генерации кода.
*   **Дополнительная задача:** Реализовать базовый вывод типов для констант.

#### **Этап 4 (Спринт 4): Промежуточное представление и простая генерация кода**
*   **Цель:** Ввести независимый от платформы промежуточный шаг и генерировать простые последовательности.
*   **Ключевые результаты:**
    1.  Проектирование и реализация простого **Промежуточного представления (IR)** (например, трёхадресный код, пользовательский набор инструкций или использование LLVM Lite, если язык реализации C++).
    2.  Первый **генератор кода**, который обходит декорированное АСД и производит IR для:
        *   Арифметических и логических выражений.
        *   Присваиваний переменных (глобальных/локальных).
        *   Простого управления потоком (например, в стиле `if-goto`).
    3.  Рабочий конвейер: `Исходный код -> АСД -> IR`.
    4.  Текстовый дампер для IR.
*   **Дополнительная задача:** Реализовать очень простую "замочную" оптимизацию (peephole) на уровне IR.

#### **Этап 5 (Спринт 5): Основа бэкенда x86-64 и прологи/эпилоги функций**
*   **Цель:** Генерировать реальный ассемблерный код x86-64 для основной среды выполнения.
*   **Ключевые результаты:**
    1.  **Управление стековым фреймом:** Генерация кода для прологов функций (push `rbp`, перемещение `rsp`, выделение места) и эпилогов в соответствии с **System V ABI**.
    2.  **Хранение переменных:** Отображение IR-временных переменных и локальных переменных в позиции стека относительно `rbp`.
    3.  **Генератор кода**, который может транслировать IR для простых **функций** (с параметрами и локальными переменными) и **операторов return** в корректный ассемблерный код.
    4.  Небольшая написанная вручную **библиотека времени выполнения** на ассемблере (например, `print_int`, `read_int`) и понимание процесса линковки.
    5.  Первая **сквозная компиляция и запуск** простой функции (например, `func add(a, b) { return a + b; }`).
*   **Дополнительная задача:** Реализовать простое распределение регистров (например, использование `rax`, `rbx`, `rcx`, `rdx` как фиксированных регистров).

#### **Этап 6 (Спринт 6): Управление потоком и сложные выражения**
*   **Цель:** Компилировать сложные языковые конструкции.
*   **Ключевые результаты:**
    1.  **Условные операторы:** Полная реализация `if`, `if-else` и операторов сравнения (`<`, `>`, `==`) с использованием условных переходов (`jge`, `jne` и т.д.).
    2.  **Циклы:** Реализация циклов `while` и `for`.
    3.  **Логические операторы:** Сокращённое вычисление для `&&` и `||`.
    4.  **Сложные выражения:** Эффективная генерация кода для вложенных выражений с правильным приоритетом операторов.
    5.  Набор тестов с программами, использующими эти управляющие структуры.
*   **Дополнительная задача:** Реализовать операторы `break` и `continue`.

#### **Этап 7 (Спринт 7): Продвинутые возможности и оптимизации**
*   **Цель:** Интегрировать оставшиеся высокоуровневые возможности и ввести оптимизации.
*   **Ключевые результаты:**
    1.  **Массивы:** Поддержка статических или размещаемых в стеке массивов (расчёт смещений).
    2.  **Интеграция с системой:** Генерация кода для вызова внешних функций библиотек C (например, `printf`, `malloc`) в соответствии с ABI.
    3.  **Базовые оптимизации:** Реализовать как минимум один проход оптимизации (например, свёртку/распространение констант на уровне IR или устранение мёртвого кода).
    4.  Нетривиальная демонстрационная программа (например, рекурсивный факториал или небольшой алгоритм сортировки), которая компилируется и запускается.
*   **Дополнительная задача:** Реализовать простое встраивание (inlining) для небольших функций.

#### **Этап 8 (Спринт 8): Интеграция, доводка и финальная демонстрация**
*   **Цель:** Создать надёжный, удобный инструмент компилятора и подготовить финальные результаты.
*   **Ключевые результаты:**
    1.  **Интерфейс командной строки:** Чистый интерфейс `./mycc [опции] <исходный_файл>` с флагами (`-o`, `-S`, `--help`).
    2.  **Надёжная обработка ошибок:** Консолидированный вывод ошибок на всех стадиях с указанием номера строки и столбца в исходном коде.
    3.  **Всеобъемлющее тестирование:** Финальный набор тестов, включающий "хорошие" программы (для проверки вывода) и "плохие" программы (для проверки сообщений об ошибках).
    4.  **Документация:** Финальный README с инструкциями по сборке, спецификацией языка и руководством по быстрому старту.
    5.  **Финальная демонстрация:** Демонстрационная программа, написанная на вашем новом языке, которая показывает все ключевые возможности, скомпилированная вашим компилятором и запущенная нативно.
*   **Дополнительная задача:** Создать простой бенчмарк, сравнивающий производительность вашего скомпилированного кода с эквивалентной программой на C.

---

### **Советы команде для успеха:**
1.  **Система контроля версий:** Активно используйте Git. Ветка на каждую функцию, частые коммиты, осмысленные сообщения.
2.  **Сначала тесты:** Для каждого этапа напишите небольшую тестовую программу *до* реализации функции.
3.  **Используйте инструменты:** Применяйте генераторы парсеров (Flex/Bison, ANTLR), но понимание ручной реализации необходимо.
4.  **Справочники:** Держите под рукой документацию по **System V ABI** и **справочник по набору инструкций x86-64**.
5.  **Начните с простого:** Получите работающий "hello world" вашего языка (например, программу, которая просто возвращает константу) сквозным образом как можно раньше, уже на Этапе 5. Это поднимает боевой дух и проверяет инструментальную цепочку.
