# **План демонстрации и презентации компилятора (5 минут)**

## **Структура выступления**

**Общее время: 5 минут**
- Введение и цель проекта: 30 секунд
- Архитектура компилятора: 1 минута
- Демонстрация работы: 2 минуты
- Особенности и сложности: 1 минута
- Заключение и результаты: 30 секунд

## **Подробный сценарий презентации**

### **Часть 1: Введение (30 секунд)**

**Слайд 1: Титульный слайд**
```
МИНИ-КОМПИЛЯТОР: OT ИСХОДНОГО КОДА ДО ВЫПОЛНЕНИЯ
[Имя Фамилия] | [Группа] | [Курс]
```

**Устное выступление:**
> "Добрый день! Сегодня я представлю компилятор для упрощённого C-подобного языка, разработанный в рамках курсового проекта. За 8 спринтов мы прошли полный путь от лексического анализа до генерации исполняемого кода для x86-64."

### **Часть 2: Архитектура компилятора (1 минута)**

**Слайд 2: Архитектурная диаграмма**
```
┌─────────────┐    ┌──────────┐    ┌─────────────┐    ┌──────────┐
│ Исходный    │    │ Абстракт-│    │ Промежуточ- │    │ Машинный │
│ код на      │───▶│ ное      │───▶│ ное         │───▶│ код      │
│ MiniLang    │    │ синтакс- │    │ представ-   │    │ x86-64   │
│             │    │ ическое  │    │ ление (IR)  │    │          │
│             │    │ дерево   │    │             │    │          │
└─────────────┘    └──────────┘    └─────────────┘    └──────────┘
       │                   │                  │              │
       ▼                   ▼                  ▼              ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ Лексический │    │ Синтакси-   │    │ Семантиче-  │    │ Оптими-     │
│ анализатор  │    │ ческий      │    │ ский анализ │    │ зации       │
│ (токены)    │    │ анализатор  │    │ (типы,      │    │ (свёртка    │
│             │    │ (грамматика)│    │ области)    │    │ констант)   │
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘
```

**Устное выступление:**
> "Компилятор реализует классическую многоэтапную архитектуру. Начинаем с лексического анализа, где исходный код разбивается на токены. Затем синтаксический анализатор строит абстрактное синтаксическое дерево согласно контекстно-свободной грамматике. На этапе семантического анализа проверяются типы и области видимости. Далее генерируется промежуточное представление, над которым выполняются оптимизации. Финальный этап — генерация ассемблерного кода для x86-64 с соблюдением System V ABI."

### **Часть 3: Демонстрация работы (2 минуты)**

**Слайд 3: Пример исходного кода**
```c
// Быстрая сортировка на MiniLang
fn quicksort(arr[], low, high) {
    if (low < high) {
        pi = partition(arr, low, high);
        quicksort(arr, low, pi - 1);
        quicksort(arr, pi + 1, high);
    }
}

fn main() {
    arr = {10, 7, 8, 9, 1, 5};
    quicksort(arr, 0, 5);
    print("Отсортировано: ", arr);
}
```

**Демонстрация в терминале (живая или записанная):**

```bash
# Показать команду компиляции
$ ./mycc -O2 -S quicksort.src -o quicksort.asm

# Показать фрагмент сгенерированного ассемблера
$ head -20 quicksort.asm
section .text
global quicksort
quicksort:
    push rbp
    mov rbp, rsp
    sub rsp, 32
    mov [rbp-8], rdi    ; arr
    mov [rbp-12], esi   ; low
    mov [rbp-16], edx   ; high
    ; ... остальной код

# Показать компиляцию и запуск
$ ./mycc quicksort.src -o quicksort
$ ./quicksort
Отсортировано: [1, 5, 7, 8, 9, 10]
```

**Устное сопровождение демонстрации:**
> "Давайте скомпилируем пример программы быстрой сортировки. Используем флаг -O2 для включения оптимизаций и -S для просмотра ассемблерного кода. Как видите, компилятор генерирует корректный ассемблерный код с прологами и эпилогами функций. Теперь скомпилируем полностью и запустим — программа работает и выводит отсортированный массив."

### **Часть 4: Особенности и сложности (1 минута)**

**Слайд 4: Ключевые особенности**
```
✓ Полная поддержка языка: переменные, функции, массивы, структуры
✓ Контрольные структуры: if/else, while, for с поддержкой break/continue
✓ Система типов с проверкой на этапе компиляции
✓ Короткое замыкание логических операторов (&&, ||)
✓ Поддержка вызовов функций из стандартной библиотеки C
✓ Оптимизации: свёртка констант, распространение констант, удаление мёртвого кода
✓ Соответствие System V AMD64 ABI
```

**Слайд 5: Технические сложности и решения**
```
Вызовы:
• Реализация рекурсивного спуска для парсера
• Управление вложенными областями видимости в таблице символов
• Генерация эффективного кода для сложных выражений
• Обеспечение выравнивания стека по ABI

Решения:
• Visitor pattern для обхода AST
• Иерархическая таблица символов с поддержкой областей
• Трёхадресный код как промежуточное представление
• Статическое выделение регистров с spill на стек
```

**Устное выступление:**
> "Среди ключевых особенностей — полная поддержка языка с системой типов, все основные контрольные структуры и интеграция со стандартной библиотекой C. Основные сложности возникли при реализации таблицы символов с поддержкой вложенных областей видимости и при обеспечении корректного выравнивания стека согласно ABI. Для решения этих проблем мы использовали иерархическую структуру таблицы символов и тщательно рассчитали layout стека."

### **Часть 5: Заключение и результаты (30 секунд)**

**Слайд 6: Результаты и будущее развитие**
```
Достигнутые результаты:
✅ Компилятор проходит 170+ тестов
✅ Поддерживает все запланированные возможности языка
✅ Генерирует рабочий x86-64 код
✅ Интегрируется со стандартными инструментами (nasm, ld)

Будущие улучшения:
• Поддержка модулей и отдельной компиляции
• Более продвинутые оптимизации (inline функций, анализ потоков данных)
• Генерация отладочной информации (DWARF)
• Поддержка других архитектур (ARM, RISC-V)
```

**Устное выступление:**
> "В результате мы получили полнофункциональный компилятор, который проходит более 170 тестов и генерирует эффективный машинный код. Проект заложил основу для дальнейшего развития — добавления более сложных оптимизаций, поддержки отладки и расширения на другие архитектуры. Спасибо за внимание! Готов ответить на вопросы."

## **Советы для успешной презентации**

### **Подготовительный этап:**

1. **Отрепетируйте тайминг:** 5 минут — это очень мало, отрепетируйте 5-7 раз с секундомером
2. **Подготовьте "демо-сценарий":** Что показываете → что говорите → куда кликаете
3. **Сделайте fallback-видео:** На случай проблем с live-демо запишите видео заранее
4. **Проверьте оборудование:** Убедитесь, что терминал виден, шрифты читаемы

### **Во время презентации:**

1. **Начните с "крючка":** "Представьте, что вам нужно написать компилятор с нуля..."
2. **Используйте визуальные метафоры:** "Таблица символов — как паспортный стол программы"
3. **Делайте акцент на ключевых достижениях:** "Самым сложным было... но мы решили через..."
4. **Держите зрительный контакт:** Смотрите на аудиторию, а не на экран
5. **Говорите уверенно:** Вы знаете проект лучше всех в комнате

### **Для демонстрации:**

```bash
# Подготовьте "шпаргалку" команд для демо:
#!/bin/bash
# demo_script.sh

# 1. Показать исходник
cat examples/quicksort.src | highlight -O ansi --syntax=c

# 2. Показать этапы компиляции
echo "=== Лексический анализ ==="
./mycc --tokens examples/quicksort.src | head -10

echo "=== AST ==="
./mycc --ast examples/quicksort.src | head -15

echo "=== Генерация ассемблера ==="
./mycc -S examples/quicksort.src -o /tmp/quicksort.asm
head -20 /tmp/quicksort.asm

echo "=== Компиляция и запуск ==="
./mycc examples/quicksort.src -o /tmp/quicksort
/tmp/quicksort
```

### **Ответы на возможные вопросы:**

**Вопрос:** "Почему выбрали именно такую архитектуру?"
**Ответ:** "Классическая многоэтапная архитектура позволяет разделить ответственность и облегчает тестирование каждого компонента отдельно."

**Вопрос:** "Какая часть была самой сложной?"
**Ответ:** "Реализация корректного управления стековым кадром согласно System V ABI, особенно обеспечение 16-байтового выравнивания перед вызовами функций."

**Вопрос:** "Как тестировали компилятор?"
**Ответ:** "Использовали комбинацию модульных тестов для каждого компонента и интеграционных тестов для полного pipeline. Также тестировали интероперабельность с GCC."

**Вопрос:** "Какие оптимизации реализованы?"
**Ответ:** "На данный момент — свёртка и распространение констант, удаление мёртвого кода. В планах — inline функций и анализ активных переменных."

## **Чек-лист перед презентацией:**

- [ ] Презентация умещается в 5 минут (репетиция с секундомером)
- [ ] Демо-скрипт работает без ошибок
- [ ] Терминал настроен (размер шрифта, цвета)
- [ ] Исходный код для демо выбран и проверен
- [ ] Подготовлены ответы на вероятные вопросы
- [ ] Резервная копия демо (видеозапись) на флешке
- [ ] Техника протестирована в аудитории заранее

**Ключевой совет:** Рассказывайте историю проекта, а не просто перечисляйте факты. "Сначала мы столкнулись с проблемой X, решили её методом Y, что позволило реализовать Z" — такая структура удержит внимание аудитории.
