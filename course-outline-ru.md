## **Построение компиляторов: Теория и практика. Программа курса**

### **Модуль 1: Основы (Лекции 1-3)**

**Лекция 1: Введение в компиляторы и обзор курса**
*   Что делают компиляторы и почему они важны
*   Исторический контекст: от FORTRAN до современных языков
*   Конвейер компиляции: 7-фазная модель
*   **Старт проекта:** Обзор 8 этапов, обсуждение спецификации языка
*   **Инструменты:** Знакомство с Git, системами сборки, фреймворками для тестирования

**Лекция 2: Теория лексического анализа**
*   Повторение формальных языков: алфавиты, строки, языки
*   Регулярные выражения и их ограничения
*   Конечные автоматы: НКА vs ДКА
*   Реализация сканеров: таблично-управляемые vs написанные вручную
*   **Связь с проектом:** Лекция перед **Этапом 1** (Реализация лексического анализатора)

**Лекция 3: Основы синтаксического анализа**
*   Контекстно-свободные грамматики: формальное определение
*   Деревья разбора vs абстрактные синтаксические деревья (АСД)
*   Неоднозначность и способы её устранения (приоритет операторов, ассоциативность)
*   **Практика:** Написание грамматики для языка вашего проекта
*   **Связь с проектом:** Поддержка для **Этапа 2** (Разработка синтаксического анализатора)

### **Модуль 2: Синтаксис и семантика (Лекции 4-7)**

**Лекция 4: Нисходящий синтаксический анализ**
*   LL(k)-грамматики и рекурсивный спуск
*   Предиктивный разбор с множествами FIRST/FOLLOW
*   Устранение левой рекурсии
*   Восстановление после ошибок в нисходящих анализаторах
*   **Связь с проектом:** Практические рекомендации для **Этапа 2**

**Лекция 5: Восходящий синтаксический анализ и генераторы анализаторов**
*   Концепции LR-разбора (shift-reduce)
*   Введение в генераторы анализаторов (Yacc/Bison, ANTLR)
*   Когда использовать написанные вручную, а когда сгенерированные анализаторы
*   **Пример из практики:** Фрагменты грамматик реальных языков

**Лекция 6: Семантический анализ I - Управление символами**
*   Роль семантического анализа в компиляции
*   Дизайн таблицы символов: хеширование, деревья, таблицы с областями видимости
*   Разрешение имён: лексическая vs динамическая область видимости
*   Введение в системы типов
*   **Связь с проектом:** Ключевая теория для **Этапа 3**

**Лекция 7: Семантический анализ II - Системы типов**
*   Алгоритмы проверки типов
*   Основы вывода типов
*   Атрибутные грамматики для семантического анализа
*   Сообщение об ошибках и восстановление в семантической фазе
*   **Связь с проектом:** Техники реализации для **Этапа 3**

### **Модуль 3: Промежуточные представления и архитектура (Лекции 8-11)**

**Лекция 8: Промежуточные представления (IR)**
*   Зачем нужны IR? Преимущества для оптимизации и переадресации
*   Обзор IR: АСД, трёхадресный код, SSA-форма, LLVM IR
*   Решения по дизайну IR для вашего проекта
*   **Связь с проектом:** Основа для **Этапа 4**

**Лекция 9: Подробный разбор архитектуры x86-64 I**
*   Регистры и их роли (общего назначения, специальные)
*   Режимы адресации памяти
*   Основные категории инструкций (перемещение данных, арифметика)
*   **Лабораторная работа:** Чтение и написание простого ассемблерного кода вручную
*   **Связь с проектом:** Необходимо для **Этапа 5**

**Лекция 10: Подробный разбор архитектуры x86-64 II**
*   Инструкции управления потоком выполнения (переходы, условные ветвления)
*   Соглашения о вызове функций (System V ABI)
*   Организация стекового фрейма (адреса возврата, сохранённые регистры, локальные переменные)
*   **Связь с проектом:** Критически важно для **Этапа 5** (реализация функций)

**Лекция 11: Среды выполнения**
*   Расположение в памяти: код, статические данные, куча, стек
*   Активные записи и управление стеком
*   **Управление кучей** (краткое введение в malloc/free)
*   Вызов внешних функций (линковка с библиотеками на C)
*   **Связь с проектом:** Поддержка для **Этапов 5 & 7**

### **Модуль 4: Генерация кода (Лекции 12-15)**

**Лекция 12: Основы генерации кода**
*   Трансляция АСД/IR в машинные инструкции
*   Стратегии вычисления выражений (стековые vs регистровые машины)
*   Простые схемы распределения регистров
*   **Связь с проектом:** Основа **Этапов 5 & 6**

**Лекция 13: Трансляция управления потоком**
*   Трансляция высокоуровневых управляющих конструкций (if, while, for)
*   Трансляция булевых выражений с сокращённым вычислением
*   Генерация и управление метками
*   **Связь с проектом:** Непосредственная поддержка **Этапа 6**

**Лекция 14: Продвинутая генерация кода**
*   Доступ к массивам и структурам
*   Реализация указателей на функции
*   **Особенности проекта** (на основе выбранного языка)

**Лекция 15: Оптимизация I - Локальные техники**
*   Спектр оптимизаций: когда и что оптимизировать
*   "Замочная" оптимизация (peephole)
*   Свёртка констант и распространение констант
*   Устранение общих подвыражений
*   **Связь с проектом:** Теория для оптимизаций **Этапа 7**

### **Модуль 5: Продвинутые темы и интеграция проекта (Лекции 16-18)**

**Лекция 16: Оптимизация II - Глобальные техники**
*   Введение в анализ потоков данных
*   Анализ активности переменных и распределение регистров
*   Введение в раскраску графов
*   **Примечание:** Студенты реализуют только основы, но теория полезна

**Лекция 17: Инженерия компиляторов в реальном мире**
*   Обработка ошибок на всех фазах
*   Генерация отладочной информации
*   Стратегии тестирования компиляторов
*   Профилирование производительности сгенерированного кода
*   **Связь с проектом:** Финальная полировка для **Этапа 8**

**Лекция 18: Завершение курса и перспективы**
*   Обзор современных тем компиляторов: JIT-компиляция, векторизация
*   Альтернативные архитектуры (RISC-V, ARM)
*   Предметно-ориентированные языки
*   **Демонстрации проектов** и извлечённые уроки
*   Карьерные пути в инженерии компиляторов

---

## **Ключевые результаты обучения**

К концу этого курса студенты смогут:
1.  Объяснять каждую фазу конвейера компиляции
2.  Проектировать и реализовывать сканер и синтаксический анализатор для нетривиального языка
3.  Выполнять семантический анализ, включая проверку типов
4.  Генерировать корректный ассемблерный код x86-64 для сложных языковых конструкций
5.  Применять базовые техники оптимизации
6.  Тестировать и отлаживать многофазную систему компилятора
